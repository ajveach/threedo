
//









;(function(){
	var threedo = {
		utility : {}
	};


	window.threedo = threedo;
})();(function(){
	var hooks = [];

	var onResize = function(f){
		if(typeof f === 'function'){
			var i = hooks.push(f);
			return i;
		}

		// Not adding a hook. Call all hooks and perform core tasks
		threedo.scene.width($(window).width());
		threedo.scene.height($(window).height());

		for(var i = 0; i < hooks.length; i += 1)
			hooks[i]();
	};

	threedo.onResize = onResize;
})();(function(){
	var hooks = {};
	var lastUpdate = new Date().getTime();

	var update = function(){
		// Update delta time
		var now = new Date().getTime();
		threedo.update.deltaTime = now - lastUpdate;
		lastUpdate = now;

		for (var k in hooks) {
			if (hooks.hasOwnProperty(k) && typeof hooks[k] === 'function') {
				hooks[k]();
			}
		}
	};

	update.add = function(name,method){
		hooks[name] = method;
	};

	update.remove = function(name){
		delete hooks[name];
	};

	update.deltaTime = 0;


	threedo.update = update;
})();(function(){
	var obj,
	loading = function(start){
		if(start){
			if(!obj){
				obj = threedo.UI.text({
					text:"Loading...",
					class:"threedo-UI-Loading",
					name:"loading"
				});
			}
			else{
				obj.$e.show();
			}
			obj.$e.children('span').css('line-height',threedo.scene.height()+"px");
		}
		else{
			obj.$e.hide();
		}
	};

	threedo.loading = loading;
})();(function(){
	var Model = function(attributes,options){
		var obj = {};

		var f = function(val){
			if(val)
				this._value = val;
			return this._value;
		};
			
		for(var i = 0; i < attributes.length; i += 1){
			obj[attributes[i]] = f.bind({_value:options[attributes[i]]});
		}

		obj.position = function(x,y,z){
			var o = this.mesh() || this.obj3D();
			if(!o)
				return this;

			o.position.x = x;
			o.position.y = y;
			o.position.z = z;

			return obj;
		};

		return obj;
	};

	threedo.Model = Model;
})();(function(threedo){
	var _width = 0,
		_height = 0,
		_viewAngle = 45,
		_aspectRatio = null,
		_near = 0.1,
		_far = 10000,
		_renderer = null,
		_camera = null,
		_cameraContainer = null,
		_scene = null,
		_backgroundColor = 0x333333,
		_backgroundAlpha = 1,
		_skybox = null;

	var _objects = {
		light : {},
		mesh : {},
		empty : {}
	};

	var scene = function(){
		return _scene;
	};

	scene.$container = null;

	/**
	 * GETTERS/SETTERS
	 */
	scene.width = function(width){
		var width = width || false;
		if(width){
			_width = width;
			// Set aspect ratio when width is changed
			scene.aspectRatio(_width/_height);
			_renderer.setSize( _width, _height );
		}
		else{
			return _width;
		}
	};
	scene.height = function(height){
		var height = height || false;
		if(height){
			_height = height;
			scene.aspectRatio(_width/_height);
			_renderer.setSize( _width, _height );
		}
		else{
			return _height;
		}
	};
	scene.viewAngle = function(angle){
		var angle = angle || false;
		if(angle){
			_viewAngle = angle;
		}
		else{
			return _viewAngle;
		}
	};
	scene.aspectRatio = function(ratio){
		var ratio = ratio || false;
		if(ratio){
			_aspectRatio = ratio;
			if(_camera){
				_camera.aspect = _aspectRatio;
	    		_camera.updateProjectionMatrix();
	    	}
		}
		else{
			return _aspectRatio;
		}
	};
	scene.near = function(near){
		var near = near || false;
		if(near){
			_near = near;
		}
		else{
			return _near;
		}
	};
	scene.far = function(far){
		var far = far || false;
		if(far){
			_far = far;
		}
		else{
			return _far;
		}
	};
	scene.backgroundColor = function(color){
		var color = color;

		if(typeof color === "number"){
			_backgroundColor = color;
			// Set background color
			_renderer.setClearColor( _backgroundColor, _backgroundAlpha );
		}
		else{
			return _backgroundColor;
		}
	};
	scene.backgroundAlpha = function(alpha){
		var alpha = alpha;

		if(typeof alpha === "number"){
			_backgroundAlpha = alpha;
			// Set background color
			_renderer.setClearColor( _backgroundColor, _backgroundAlpha );
		}
		else{
			return _backgroundAlpha;
		}
	};
	scene.skybox = function(images){
		if(!images)
			return _skybox;

		if(!_skybox)
			_skybox = {};

		if(images){
			_skybox.materials = [];
			for(var i = 0; i < 6; i += 1){
				_skybox.materials.push(new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture(images[i]),
					side : THREE.BackSide
				}));
			}
		}

		if(!_skybox.mesh){
			_skybox.mesh = new THREE.Mesh(
			    new THREE.BoxGeometry( scene.far(), scene.far(), scene.far()),
			    new THREE.MeshFaceMaterial( _skybox.materials )
			);
			_cameraContainer.add(_skybox.mesh);
		}
	};

	/**
	 * GETTER ONLY
	 */
	scene.renderer = function(){
		return _renderer;
	};
	scene.camera = function(){
		return _camera;
	};
	scene.camera.position = function(x,y,z){
		console.log(x,y,z);
		console.log(_camera.position);
		_cameraContainer.position.set(x,y,z);
	};
	scene.light = function(name){
		return _objects.light[name];
	};
	scene.mesh = function(name){
		return _objects.mesh[name];
	};

	/**
	 * WRAPPER METHODS
	 */
	scene.add = function(type,name,object){
		if(_objects[type]){
			_objects[type][name] = object;
			_scene.add(object);
			return object;
		}
		return false;
	};

	/**
	 * PRIMARY METHODS
	 */
	scene.init = function(next){
		scene.$container 	= $("#threedo");
		_width 				= scene.$container.width();
		_height 			= scene.$container.height();
		scene.aspectRatio(_width/_height);

		_renderer = new THREE.WebGLRenderer();
		_camera = new THREE.PerspectiveCamera(
			_viewAngle,
			_aspectRatio,
			_near,
			_far
		);

		_scene = new THREE.Scene();
		_cameraContainer = new THREE.Object3D();
		_cameraContainer.add(_camera);
		_scene.add(_cameraContainer);

		_renderer.setSize(_width, _height);
		_renderer.setClearColor( _backgroundColor, _backgroundAlpha );

		scene.$container.append(_renderer.domElement);

					// MOVE OUTSITE INIT
					// create a point light
					var demoLight = new THREE.PointLight(0xFFFFFF);

					// set its position
					demoLight.position.x = 10;
					demoLight.position.y = 50;
					demoLight.position.z = 130;

					// add to the scene
					scene.add("light","demoLight",demoLight);

		// Add loader utility (must be done during init)
		threedo.utility.loader = new THREE.JSONLoader();

		// Bind on resize event
		$(window).resize(threedo.onResize);

		_animate();

		next();
	};

	var _animate = function(){
		requestAnimationFrame(_animate);
		stats.begin();
			threedo.update();
			_renderer.render(_scene, _camera);
		stats.end();
	};

	threedo.scene = scene;
})(threedo);(function(){
	var elements = {
		text : {},
		select : {}
	};

	var UI = function(type,id){
		if(elements[type] && elements[type][id])
			return elements[type][id];
		
		if(typeof type === "object"){
			var obj = type;
			elements[obj.type][obj.name] = obj;
			return obj;
		}

		return false;
	};

	UI.onResize = function(){
		$.each(elements,function(type,list){
			$.each(list,function(name,obj){
				obj.position();
			});
		});
	};

	UI.position = function(){
		console.log(this);
	};

	UI.New = function(type,params){
		if(typeof params !== "object")
			return false;

		if(!params.name)
			return false;

		var position = params.position || {
			top : 0,
			right : null,
			left : 0,
			bottom : null
		};

		params.class = params.class || "";

		var obj = {
			name : params.name,
			type : type,
			class : params.class
		};

		obj.position = function(){
			// Set position
			if(typeof obj.position.left === "number"){
				obj.$e.css("left",obj.position.left);
			}
			else if(typeof obj.position.right === "number"){
				obj.$e.css("left",threedo.scene.width() - obj.position.right);
			}

			if(typeof obj.position.top === "number"){
				obj.$e.css("top",obj.position.top);
			}
			else if(typeof obj.position.bottom === "number"){
				obj.$e.css("top",threedo.scene.height() - obj.position.bottom);
			}

			return obj;
		};

		obj.position.left = position.left;
		obj.position.right = position.right;
		obj.position.top = position.top;
		obj.position.bottom = position.bottom;

		return obj;
	};

	threedo.UI = UI;
	threedo.onResize(UI.onResize);
})();(function(){
	var line = function(){
		
	};
})();(function(){
	var select = function(params){
		var obj = threedo.UI.New("select",params);

		obj.add = function(name,value,bindings){
			var $option = $("<div />").addClass("option").attr('data-value',value).html(name).appendTo(this.$e.children('.options'));

			var bindings = bindings || {};

			$option.on(bindings);

			return this;
		};

		obj.expand = function(){
			obj.$e.children('.options').show();
		};

		obj.collapse = function(){
			obj.$e.children('.options').hide();
		};

		params.options = params.options || [];

		obj.$e = $("<div />").addClass("threedo-UI threedo-UI-select "+params.class).attr('data-name',params.name).prependTo(threedo.scene.$container);
		obj.position();

		var $label = $("<div />").addClass('label').html(params.text).appendTo(obj.$e);
		$("<div />").addClass('arrow-down').prependTo($label);
		$("<div />").addClass('options').appendTo(obj.$e);
		for(var i = 0; i < params.options.length; i += 1)
			obj.$e.children('.options').append("<div class='option' data-value='"+params.options[i].value+"'>"+params.options[i].name+"</div>");

		obj.$e.children('.label').click(function(e){
			obj.$e.children('.options').toggle();
		});

		obj.$e.hover(function(){
			obj.$e.addClass('hover');
		},
		function(){
			obj.collapse();
			obj.$e.removeClass('hover');
		});

		threedo.UI(obj);

		return obj;
	};

	threedo.UI.select = select;
})();(function(){
	/**
	 * Method to create text UI element
	 * Required Params:
	 * 	 text (String)
	 *
	 * Optional Params:
	 *   position (Vector2)
	 *   class (String)
	 *
	 */
	var text = function(params){
		var obj = threedo.UI.New("text",params);

		if(!params.text)
			return console.log("A \"text\" option must be provided for a text UI element");

		obj.$e = $("<div />").addClass("threedo-UI threedo-UI-text "+params.class).html("<span>"+params.text+"</span>").attr('data-name',params.name).prependTo(threedo.scene.$container);
		obj.position();

		threedo.UI(obj);

		return obj;
	};

	threedo.UI.text = text;
})();//# sourceMappingURL=threedo.min.js.map